#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(non_snake_case)]
#![allow(dead_code)]
#![allow(unused_macros)]

use itertools::Itertools;
use proconio::{
    fastout, input,
    marker::{Bytes, Chars, Usize1},
};

macro_rules! debug {
    ( $($val:expr),* $(,)* ) => {{
        #[cfg(debug_assertions)]
        eprintln!( concat!($(stringify!($val), " = {:?}, "),*), $($val),* );
    }};
}

macro_rules! debug2D {
    ( $array:expr ) => {{
        #![cfg(debug_assertions)]
        eprintln!("{}: ", stringify!($array));
        for row in &$array {
            eprintln!("{:?}", row);
        }
    }};
}

// constant
const MOD1: usize = 1_000_000_007;
const MOD9: usize = 998_244_353;
const INF: usize = 1001001001001001001;

fn main() {
    input! {
        N: usize,
        M: usize,
        A: [isize; N],
        B: [usize; M]
    }

    // 遅延セグ木
    let mut seg = LazySegmentTree::<Alg::RSQandRAQ>::from(&A);

    for &b in &B {

        // ボールの数
        let cnt = seg.get(b..=b);
        // 取り除く
        seg.apply(b..=b, -cnt);
        // 全体に加算する個数
        let all = cnt / N as isize;
        // 1つ加算する区間
        let rem = (cnt % N as isize) as usize;

        // 全体に可算
        if all > 0 {
            seg.apply(.., all);
        }
        // 区間
        let C = 1;
        let left = (C + b) % N;
        let right = (left + rem) % N;
        debug!(C, left, right);

        if left <= right {
            seg.apply(left..right, 1);
        } else {
            seg.apply(left.., 1);
            seg.apply(..right, 1);
        }

        // デバッグ
        if cfg!(debug_assertions) {
            let ans = (0..N).map(|i| seg.get(i..=i)).collect_vec();

            eprintln!("{}", ans.iter().join(" "));
        }
    }

    let ans = (0..N).map(|i| seg.get(i..=i)).collect_vec();

    println!("{}", ans.iter().join(" "));
}

use core::fmt;
use std::ops::{
    Bound::{Excluded, Included, Unbounded},
    RangeBounds,
};
/// 作用付きモノイド
pub trait ExtMonoid {
    /// 要素のデータ型
    type X: Clone + PartialEq;
    /// 作用素のデータ型
    type M: Clone + PartialEq;
    /// 要素Xの単位元
    const IX: Self::X;
    /// 作用素Mの単位元
    const IM: Self::M;
    /// 要素同士の演算
    fn operate_x(x: &Self::X, y: &Self::X) -> Self::X;
    /// 要素に対する作用
    fn apply(x: &Self::X, y: &Self::M) -> Self::X;
    /// 作用素同士の演算
    fn operate_m(x: &Self::M, y: &Self::M) -> Self::M;
    /// 作用素の集約
    fn aggregate(x: &Self::M, p: usize) -> Self::M;
}
/// 遅延評価セグメント木
#[derive(Debug)]
pub struct LazySegmentTree<T: ExtMonoid> {
    pub size: usize,
    offset: usize,
    data: Vec<T::X>,
    lazy: Vec<T::M>,
}
impl<T: ExtMonoid> LazySegmentTree<T> {
    #[inline]
    fn parse_range<R: RangeBounds<usize>>(&self, range: &R) -> Option<(usize, usize)> {
        let start = match range.start_bound() {
            Unbounded => 0,
            Excluded(&v) => v + 1,
            Included(&v) => v,
        };
        let end = match range.end_bound() {
            Unbounded => self.size,
            Excluded(&v) => v,
            Included(&v) => v + 1,
        };
        if start <= end && end <= self.size {
            Some((start, end))
        } else {
            None
        }
    }
    /// 遅延評価セグメント木を初期化する
    /// - `n`: 配列サイズ
    pub fn new(n: usize) -> Self {
        let offset = n.next_power_of_two();
        Self {
            size: n,
            offset,
            data: vec![T::IX; offset << 1],
            lazy: vec![T::IM; offset << 1],
        }
    }
    /// 遅延値を評価
    fn eval(&mut self, idx: usize, len: usize) {
        if self.lazy[idx] == T::IM {
            return;
        }
        // 葉でなければ子に伝搬
        if idx < self.offset {
            self.lazy[idx * 2] = T::operate_m(&self.lazy[idx * 2], &self.lazy[idx]);
            self.lazy[idx * 2 + 1] = T::operate_m(&self.lazy[idx * 2 + 1], &self.lazy[idx]);
        }
        // 自身を更新
        self.data[idx] = T::apply(&self.data[idx], &T::aggregate(&self.lazy[idx], len));
        self.lazy[idx] = T::IM;
    }
    /// 区間に`val`を作用させる
    /// - `range`: `[left, right)`
    pub fn apply<R: RangeBounds<usize> + fmt::Debug>(&mut self, range: R, val: T::M) {
        let Some((left, right)) = self.parse_range(&range) else {
            panic!("The given range is wrong: {:?}", range);
        };
        self.apply_inner(left, right, val, 0, self.offset, 1);
    }
    fn apply_inner(
        &mut self,
        left: usize,
        right: usize,
        val: T::M,
        begin: usize,
        end: usize,
        idx: usize,
    ) {
        // 遅延値を評価
        self.eval(idx, end - begin);
        // 区間を内包するとき
        if left <= begin && end <= right {
            self.lazy[idx] = T::operate_m(&self.lazy[idx], &val);
            self.eval(idx, end - begin);
        }
        // 区間が重なるとき
        else if left < end && begin < right {
            let mid = (begin + end) / 2;
            // 左の子を更新
            self.apply_inner(left, right, val.clone(), begin, mid, idx * 2);
            // 右の子を更新
            self.apply_inner(left, right, val, mid, end, idx * 2 + 1);
            // 値を更新
            self.data[idx] = T::operate_x(&self.data[idx * 2], &self.data[idx * 2 + 1]);
        }
    }
    /// 区間を取得する
    /// - `range`: `[left, right)`
    pub fn get<R: RangeBounds<usize> + fmt::Debug>(&mut self, range: R) -> T::X {
        let Some((left, right)) = self.parse_range(&range) else {
            panic!("The given range is wrong: {:?}", range);
        };
        self.get_inner(left, right, 0, self.offset, 1)
    }
    fn get_inner(
        &mut self,
        left: usize,
        right: usize,
        begin: usize,
        end: usize,
        idx: usize,
    ) -> T::X {
        // 遅延値を評価
        self.eval(idx, end - begin);
        // 区間を含まない
        if end <= left || right <= begin {
            T::IX
        }
        // 区間を包含する
        else if left <= begin && end <= right {
            self.data[idx].clone()
        }
        // 区間が重なる
        else {
            let mid = (begin + end) / 2;
            let l_val = self.get_inner(left, right, begin, mid, idx * 2);
            let r_val = self.get_inner(left, right, mid, end, idx * 2 + 1);
            T::operate_x(&l_val, &r_val)
        }
    }
}
impl<T: ExtMonoid> From<&Vec<T::X>> for LazySegmentTree<T> {
    fn from(src: &Vec<T::X>) -> Self {
        let mut seg = Self::new(src.len());
        for (i, v) in src.iter().enumerate() {
            seg.data[seg.offset + i] = v.clone();
        }
        for i in (0..seg.offset).rev() {
            let lch = i << 1;
            seg.data[i] = T::operate_x(&seg.data[lch], &seg.data[lch + 1]);
        }
        seg
    }
}
pub mod Alg {
    use super::ExtMonoid;
    /// ## RSQandRAQ
    /// - 区間加算
    /// - 区間和
    #[derive(Debug)]
    pub struct RSQandRAQ;
    impl ExtMonoid for RSQandRAQ {
        type X = isize;
        type M = isize;
        const IX: Self::X = 0;
        const IM: Self::M = 0;
        fn operate_x(x: &Self::X, y: &Self::X) -> Self::X {
            x + y
        }
        fn apply(x: &Self::X, y: &Self::M) -> Self::X {
            x + y
        }
        fn operate_m(x: &Self::M, y: &Self::M) -> Self::M {
            x + y
        }
        fn aggregate(x: &Self::M, p: usize) -> Self::M {
            x * (p as isize)
        }
    }
    /// ## RMQandRUQ
    /// - 区間更新
    /// - 区間最小値
    #[derive(Debug)]
    pub struct RMQandRUQ;
    impl ExtMonoid for RMQandRUQ {
        type X = isize;
        type M = isize;
        const IM: Self::M = (1 << 31) - 1;
        const IX: Self::X = (1 << 31) - 1;
        fn operate_x(x: &Self::X, y: &Self::X) -> Self::X {
            *x.min(y)
        }
        fn apply(_x: &Self::X, y: &Self::M) -> Self::X {
            *y
        }
        fn operate_m(_x: &Self::M, y: &Self::M) -> Self::M {
            *y
        }
        fn aggregate(x: &Self::M, _p: usize) -> Self::M {
            *x
        }
    }
    /// ## RMQandRAQ
    /// - 区間加算
    /// - 区間最小値
    #[derive(Debug)]
    pub struct RMQandRAQ;
    impl ExtMonoid for RMQandRAQ {
        type X = isize;
        type M = isize;
        const IM: Self::M = 0;
        const IX: Self::X = 1 << 31;
        fn operate_x(x: &Self::X, y: &Self::X) -> Self::X {
            *x.min(y)
        }
        fn apply(x: &Self::X, y: &Self::M) -> Self::X {
            x + y
        }
        fn operate_m(x: &Self::M, y: &Self::M) -> Self::M {
            x + y
        }
        fn aggregate(x: &Self::M, _p: usize) -> Self::M {
            *x
        }
    }
    /// ## RSQandRUQ
    /// - 区間更新
    /// - 区間和取得
    #[derive(Debug)]
    pub struct RSQandRUQ;
    impl ExtMonoid for RSQandRUQ {
        type X = isize;
        type M = Option<isize>;
        const IX: Self::X = 0;
        const IM: Self::M = None;
        fn operate_x(x: &Self::X, y: &Self::X) -> Self::X {
            x + y
        }
        fn apply(_x: &Self::X, y: &Self::M) -> Self::X {
            y.unwrap()
        }
        fn operate_m(_x: &Self::M, y: &Self::M) -> Self::M {
            *y
        }
        fn aggregate(x: &Self::M, p: usize) -> Self::M {
            x.map(|x| x * p as isize)
        }
    }
}

===== ↑ /home/powell/develop/algo/kyopro/contests/abc340/src/bin/e.rs | ↓ /home/powell/develop/algo/kyopro/atcoder_training/abc340/src/bin/e.rs =====
#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(non_snake_case)]
#![allow(dead_code)]
#![allow(unused_macros)]

macro_rules! debug {
    ( $($val:expr),* $(,)* ) => {{
        #[cfg(debug_assertions)]
        eprintln!( concat!($(stringify!($val), " = {:?}, "),*), $($val),* );
    }};
}
macro_rules! debug2D {
    ( $array:expr ) => {{
        #![cfg(debug_assertions)]
        eprintln!("{}: ", stringify!($array));
        for row in &$array {
            eprintln!("{:?}", row);
        }
    }};
}

use itertools::Itertools;
use proconio::{
    input,
    marker::{Bytes, Chars, Usize1},
};

use crate::dual_segment_tree::{Alg, DualSegmentTree};

fn main() {
    input! {
        N: usize,
        M: usize,
        A: [isize; N],
        B: [usize; M],
    }

    // 双対セグ木
    let mut seg = DualSegmentTree::<Alg::Add>::build(&A);

    for &b in &B {
        // ボールの数
        let cnt = seg.get_point(b);
        // 取り除く
        seg.apply_range(b..=b, -cnt);
        // 全体に加算する個数
        let all = cnt / N as isize;
        // 1つ加算する区間
        let rem = (cnt % N as isize) as usize;

        // 全体に可算
        if all > 0 {
            seg.apply_range(.., all);
        }
        // 区間
        let C = 1;
        let left = (C + b) % N;
        let right = (left + rem) % N;
        debug!(C, left, right);

        if left <= right {
            seg.apply_range(left..right, 1);
        } else {
            seg.apply_range(left.., 1);
            seg.apply_range(..right, 1);
        }

        // デバッグ
        debug!(seg);
    }

    let ans = (0..N).map(|i| seg.get_point(i)).collect_vec();

    println!("{}", ans.iter().join(" "));
}

mod dual_segment_tree {
    use std::fmt::{self, Debug};
    use std::ops::{
        Bound::{Excluded, Included, Unbounded},
        RangeBounds,
    };
    /// 可換モノイド
    pub trait CommutativeMonoid {
        /// 元の型
        type Val: fmt::Debug + Clone + PartialEq;
        /// 単位元
        const E: Self::Val;
        /// 演算
        fn op(arg1: &Self::Val, arg2: &Self::Val) -> Self::Val;
    }
    /// 双対セグ木
    /// - 区間への作用
    /// - 一点の取得
    /// を行うセグメント木
    pub struct DualSegmentTree<M: CommutativeMonoid> {
        pub size: usize,
        offset: usize,
        data: Vec<M::Val>,
    }
    impl<M: CommutativeMonoid> DualSegmentTree<M> {
        #[inline]
        fn parse_range<R: RangeBounds<usize>>(&self, range: &R) -> Option<(usize, usize)> {
            let start = match range.start_bound() {
                Unbounded => 0,
                Excluded(&v) => v + 1,
                Included(&v) => v,
            };
            let end = match range.end_bound() {
                Unbounded => self.size,
                Excluded(&v) => v,
                Included(&v) => v + 1,
            };
            if start <= end && end <= self.size {
                Some((start, end))
            } else {
                None
            }
        }
        /// 双対セグメント木を初期化する
        pub fn new(n: usize) -> Self {
            let offset = n;
            Self {
                size: n,
                offset,
                data: vec![M::E; offset << 1],
            }
        }
        /// 配列から双対セグメント木を構築する
        pub fn build(arr: &Vec<M::Val>) -> Self {
            let offset = arr.len();
            let mut seg = Self::new(offset);
            seg.data[offset..].clone_from_slice(&arr);
            seg
        }
        /// 区間更新:
        /// - 区間`range`を`x`で更新する
        pub fn apply_range<R: RangeBounds<usize> + Debug>(&mut self, range: R, x: M::Val) {
            let Some((start, end)) = self.parse_range(&range) else {
                panic!("The given range is wrong: {:?}", range);
            };
            // 値の更新
            let mut l = self.offset + start;
            let mut r = self.offset + end;
            while l < r {
                if l & 1 == 1 {
                    let tmp = M::op(&self.data[l], &x);
                    self.data[l] = tmp;
                    l += 1;
                }
                if r & 1 == 1 {
                    r -= 1;
                    let tmp = M::op(&self.data[r], &x);
                    self.data[r] = tmp;
                }
                l >>= 1;
                r >>= 1;
            }
        }
        /// 一点取得
        pub fn get_point(&self, index: usize) -> M::Val {
            let mut i = index + self.offset;
            let mut res = self.data[i].clone();
            while i > 1 {
                i >>= 1;
                let tmp = M::op(&self.data[i], &res);
                res = tmp;
            }
            res
        }
    }
    impl<M: CommutativeMonoid + Debug> Debug for DualSegmentTree<M> {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            write!(f, "DualSegmentTree {{ [").ok();
            for i in 0..self.size {
                if i + 1 < self.size {
                    write!(f, "{:?}, ", self.get_point(i)).ok();
                } else {
                    write!(f, "{:?}", self.get_point(i)).ok();
                }
            }
            write!(f, "] }}")
        }
    }
    pub mod Alg {
        use super::CommutativeMonoid;
        use std::{fmt::Debug, marker::PhantomData};
        /// 整数の和
        #[derive(Debug)]
        pub struct Add;
        impl CommutativeMonoid for Add {
            type Val = isize;
            const E: Self::Val = 0;
            fn op(arg1: &Self::Val, arg2: &Self::Val) -> Self::Val {
                arg1 + arg2
            }
        }
        /// bit単位の排他的論理和
        pub struct Xor;
        impl CommutativeMonoid for Xor {
            type Val = usize;
            const E: Self::Val = 0;
            fn op(arg1: &Self::Val, arg2: &Self::Val) -> Self::Val {
                arg1 ^ arg2
            }
        }
        /// chmin操作
        #[derive(Debug)]
        pub struct Min;
        impl CommutativeMonoid for Min {
            type Val = isize;
            const E: Self::Val = isize::MAX;
            fn op(arg1: &Self::Val, arg2: &Self::Val) -> Self::Val {
                *arg1.min(arg2)
            }
        }
    }
}
